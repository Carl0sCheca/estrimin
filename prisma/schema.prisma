generator client {
  provider        = "prisma-client"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "linux-musl-openssl-3.0.x"]
  output          = "../src/generated"
}

datasource db {
  provider   = "postgresql"
  extensions = [citext]
}

enum Role {
  USER
  ADMIN
}

enum ChannelVisibility {
  ALL
  REGISTERED_USERS
  ALLOWLIST
  PASSWORD
  UNLISTED
}

enum RecordingVisibility {
  PUBLIC
  ALLOWLIST
  UNLISTED
  PRIVATE
}

model User {
  id                      String             @id
  name                    String             @unique @db.Citext
  email                   String
  emailVerified           Boolean
  image                   String?
  createdAt               DateTime
  updatedAt               DateTime
  role                    Role               @default(USER)
  sessions                Session[]
  accounts                Account[]
  Channel                 Channel?
  channelAllowListUsersId Int?
  ChannelAllowList        ChannelAllowList[] @relation("UserChannels")
  RegistrationCodes       RegistrationCode[]
  UserSettings            UserSetting[]
  RecordingQueue          RecordingQueue[]

  followers UserFollows[] @relation("UserFollowers")
  following UserFollows[] @relation("UserFollowing")

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String
  createdAt DateTime
  updatedAt DateTime

  @@unique([token])
  @@map("session")
}

model Account {
  id           String    @id
  accountId    String
  providerId   String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken  String?
  refreshToken String?
  idToken      String?
  expiresAt    DateTime?
  password     String?

  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime

  createdAt DateTime?
  updatedAt DateTime?

  @@map("verification")
}

model Channel {
  id                 Int                @id @default(autoincrement())
  token              String
  userId             String             @unique
  visibility         ChannelVisibility  @default(ALL)
  visibilityPassword String?
  disabled           Boolean            @default(false)
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  channelAllowList   ChannelAllowList[] @relation("ChannelUsers")
  RecordingsSaved    RecordingSaved[]
  isOnline           Boolean            @default(false)
  lastOnline         DateTime?

  @@map("channel")
}

model ChannelAllowList {
  id        Int     @id @default(autoincrement())
  channelId Int
  userId    String
  Channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade, name: "ChannelUsers")
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade, name: "UserChannels")

  @@unique([channelId, userId])
  @@map("channelAllowList")
}

model RegistrationCode {
  id             String    @id @default(uuid())
  used           Boolean   @default(false)
  createdAt      DateTime  @default(now())
  expirationDate DateTime?
  usedById       String?

  user User? @relation(fields: [usedById], references: [id], onDelete: NoAction)

  @@map("registrationCode")
}

model RecordingSaved {
  id         String              @id @default(uuid())
  createdAt  DateTime            @default(now())
  channelId  Int
  duration   Float               @default(0)
  visibility RecordingVisibility @default(PRIVATE)
  title      String?             @db.VarChar(255)

  channel Channel @relation(fields: [channelId], references: [id], onDelete: NoAction)

  @@map("recordingSaved")
}

model SiteSetting {
  key   String @id
  value Json

  @@map("siteSetting")
}

model UserSetting {
  key   String
  value Json

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, key])
  @@map("userSetting")
}

enum RecordingQueueState {
  RECORDING
  UPLOADING
  UPLOADED
  PENDING
  ENCODING
  ENCODED_UPLOADING
  ENCODED
  MERGING
  MERGING_UPLOADING
  MERGED
  COMPLETED
  FAILED
  EXPIRED
}

model RecordingQueue {
  id            Int                  @id @default(autoincrement())
  status        RecordingQueueState  @default(RECORDING)
  fileName      String
  duration      Float
  userId        String
  user          User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime             @default(now())
  startedAt     DateTime?
  finishedAt    DateTime?
  attempts      Int                  @default(0)
  errorMessage  String?
  errorState    RecordingQueueState?
  visibility    RecordingVisibility  @default(PUBLIC)
  segmentsIndex Int[]

  firstSegmentId Int?
  firstSegment   RecordingQueue?  @relation("SegmentRelation", fields: [firstSegmentId], references: [id])
  segments       RecordingQueue[] @relation("SegmentRelation")

  mergingWithId Int?            @unique
  mergingWith   RecordingQueue? @relation("MergingRelation", fields: [mergingWithId], references: [id])
  mergedFrom    RecordingQueue? @relation("MergingRelation")

  @@index([status])
  @@index([userId])
  @@map("recordingQueue")
}

model UserFollows {
  userId   String
  followId String

  follower User @relation("UserFollowers", fields: [userId], references: [id], onDelete: Cascade)
  followed User @relation("UserFollowing", fields: [followId], references: [id], onDelete: Cascade)

  @@unique([userId, followId])
  @@index([userId])
  @@index([followId])
  @@map("userFollows")
}
